x-common: &common
  logging:
    driver: json-file
    options:
      max-size: "5m"
      max-file: "2"
  restart: unless-stopped

x-healthcheck-db: &healthcheck-db
  test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
  interval: 15s
  timeout: 3s
  retries: 3
  start_period: 10s

x-healthcheck-cache: &healthcheck-cache
  test: ["CMD", "redis-cli", "--no-auth-warning", "-a", "$${REDIS_PASSWORD}", "ping"]
  interval: 15s
  timeout: 3s
  retries: 3
  start_period: 5s

x-healthcheck-app: &healthcheck-app
  interval: 30s
  timeout: 5s
  retries: 3

services:
  postgres:
    image: postgis/postgis:16-3.4-alpine
    container_name: ${ENV}-db
    environment:
      POSTGRES_DB: ${DATABASE_NAME}
      POSTGRES_USER: ${DATABASE_USER}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_INITDB_ARGS: "-E UTF8"
      PGDATA: /var/lib/postgresql/data/pgdata
    ports:
      - 127.0.0.1:${DB_PORT}:5432
    volumes:
      - db_data:/var/lib/postgresql/data
      - ./init-db.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks:
      - app
    healthcheck: *healthcheck-db
    <<: *common
    deploy:
      resources:
        limits:
          cpus: "${DB_CPU_LIMIT}"
          memory: ${DB_MEM_LIMIT}
        reservations:
          cpus: "${DB_CPU_RESERVE}"
          memory: ${DB_MEM_RESERVE}
    command:
      - postgres
      - -c
      - shared_buffers=${DB_SHARED_BUFFERS}
      - -c
      - effective_cache_size=${DB_CACHE_SIZE}
      - -c
      - work_mem=${DB_WORK_MEM}
      - -c
      - maintenance_work_mem=${DB_MAINT_WORK_MEM}
      - -c
      - max_connections=${DB_MAX_CONN}
      - -c
      - max_wal_size=${DB_MAX_WAL}
      - -c
      - checkpoint_completion_target=0.9
      - -c
      - wal_buffers=16MB
      - -c
      - random_page_cost=1.1
      - -c
      - effective_io_concurrency=200
      - -c
      - log_statement=none
      - -c
      - log_duration=off

  redis:
    image: redis:7-alpine
    container_name: ${ENV}-cache
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --maxmemory ${REDIS_MAXMEM}
      --maxmemory-policy allkeys-lru
      --save ""
      --appendonly no
    ports:
      - 127.0.0.1:${REDIS_PORT}:6379
    volumes:
      - cache_data:/data
    networks:
      - app
    healthcheck: *healthcheck-cache
    <<: *common
    deploy:
      resources:
        limits:
          cpus: "${REDIS_CPU_LIMIT}"
          memory: ${REDIS_MEM_LIMIT}
        reservations:
          cpus: "${REDIS_CPU_RESERVE}"
          memory: ${REDIS_MEM_RESERVE}

  backend:
    image: ${REGISTRY}backend:${VERSION}
    container_name: ${ENV}-api
    environment:
      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILE}
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/${DATABASE_NAME}
      SPRING_DATASOURCE_USERNAME: ${DATABASE_USER}
      SPRING_DATASOURCE_PASSWORD: ${DATABASE_PASSWORD}
      SPRING_DATA_REDIS_HOST: redis
      SPRING_DATA_REDIS_PORT: 6379
      SPRING_DATA_REDIS_PASSWORD: ${REDIS_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}
      JWT_EXPIRATION: ${JWT_EXPIRATION}
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS}
      STRIPE_API_KEY: ${STRIPE_API_KEY:-}
      STRIPE_WEBHOOK_SECRET: ${STRIPE_WEBHOOK_SECRET:-}
      MAIL_HOST: ${MAIL_HOST}
      MAIL_PORT: ${MAIL_PORT}
      MAIL_USERNAME: ${MAIL_USERNAME}
      MAIL_PASSWORD: ${MAIL_PASSWORD}
      JAVA_OPTS: ${JAVA_OPTS}
      TZ: UTC
    ports:
      - 127.0.0.1:${API_PORT}:8080
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - app
    volumes:
      - uploads:/app/uploads
    healthcheck:
      <<: *healthcheck-app
      test: ["CMD", "wget", "-qO-", "http://localhost:8080/actuator/health"]
      start_period: 45s
    <<: *common
    deploy:
      resources:
        limits:
          cpus: "${API_CPU_LIMIT}"
          memory: ${API_MEM_LIMIT}
        reservations:
          cpus: "${API_CPU_RESERVE}"
          memory: ${API_MEM_RESERVE}

  frontend:
    image: ${REGISTRY}frontend:${VERSION}
    container_name: ${ENV}-web
    environment:
      NODE_ENV: production
      NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL}
      NEXT_PUBLIC_WS_URL: ${NEXT_PUBLIC_WS_URL}
      TZ: UTC
    ports:
      - 127.0.0.1:${WEB_PORT}:3000
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - app
    healthcheck:
      <<: *healthcheck-app
      test: ["CMD", "wget", "-qO-", "http://localhost:3000/api/health"]
      start_period: 30s
    <<: *common
    deploy:
      resources:
        limits:
          cpus: "${WEB_CPU_LIMIT}"
          memory: ${WEB_MEM_LIMIT}
        reservations:
          cpus: "${WEB_CPU_RESERVE}"
          memory: ${WEB_MEM_RESERVE}

  nginx:
    image: nginx:alpine
    container_name: ${ENV}-proxy
    environment:
      ENV: ${ENV}
      DOMAIN: ${DOMAIN}
    ports:
      - ${HTTP_PORT}:80
      - ${HTTPS_PORT}:443
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./app.conf.template:/etc/nginx/templates/default.conf.template:ro
      - /etc/letsencrypt:/etc/letsencrypt:ro
      - /etc/ssl/certs/dhparam.pem:/etc/ssl/certs/dhparam.pem:ro
      - proxy_cache:/var/cache/nginx
    depends_on:
      frontend:
        condition: service_healthy
      backend:
        condition: service_healthy
    networks:
      - app
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost/health"]
      interval: 15s
      timeout: 3s
      retries: 3
      start_period: 10s
    <<: *common
    deploy:
      resources:
        limits:
          cpus: "${NGINX_CPU_LIMIT}"
          memory: ${NGINX_MEM_LIMIT}
        reservations:
          cpus: "${NGINX_CPU_RESERVE}"
          memory: ${NGINX_MEM_RESERVE}

networks:
  app:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: br-${ENV}

volumes:
  db_data:
  cache_data:
  uploads:
  proxy_cache:
